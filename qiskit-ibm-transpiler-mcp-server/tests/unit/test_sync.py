from qiskit_ibm_transpiler_mcp_server.sync import (
    ai_routing_sync,
    ai_clifford_synthesis_sync,
    ai_linear_function_synthesis_sync,
    ai_pauli_network_synthesis_sync,
    ai_permutation_synthesis_sync,
    setup_ibm_quantum_account_sync,
)

import pytest


class TestAIRoutingSync:
    """Test AIRouting sync tool."""

    def test_ai_routing_sync_success(self, mocker, mock_circuit_qasm, mock_backend):
        """
        Successful test AI routing sync tool with mocked backend, QASM quantum circuit and PassManager
        """
        mock_response = {
            "status": "success",
            "optimized_circuit_qasm": "optimized_circuit_qasm",
        }
        mocker_run_sync = mocker.patch(
            "qiskit_ibm_transpiler_mcp_server.sync._run_async",
            return_value=mock_response,
        )
        result = ai_routing_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "success"
        assert result["optimized_circuit_qasm"] == "optimized_circuit_qasm"
        mocker_run_sync.assert_called_once()

    @pytest.mark.parametrize(
        "get_backend_fixture, load_qasm_fixture, pass_manager_fixture, dumps_fixture, ai_routing_fixture, expected_message",
        [
            (
                "mock_get_backend_service_failure",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_routing_success",
                "get_backend failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_failure",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_routing_success",
                "Error in loading QuantumCircuit from QASM3.0",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_failure",
                "mock_dumps_qasm_success",
                "mock_ai_routing_success",
                "PassManager run failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_failure",
                "mock_ai_routing_success",
                "QASM dumps failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_routing_failure",
                "AIRouting failed",
            ),
        ],
        indirect=[
            "get_backend_fixture",
            "load_qasm_fixture",
            "pass_manager_fixture",
            "dumps_fixture",
            "ai_routing_fixture",
        ],
    )
    def test_ai_routing_sync_failures_parametrized(
        self,
        get_backend_fixture,
        load_qasm_fixture,
        pass_manager_fixture,
        ai_routing_fixture,
        dumps_fixture,
        expected_message,
        mock_circuit_qasm,
        mock_backend,
    ):
        """
        Failed test AI routing sync tool with existing backend, quantum circuit and PassManager
        """
        result = ai_routing_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "error"
        assert expected_message in result["message"]


class TestAICliffordSync:
    """Test AI Clifford synthesis sync tool."""

    def test_ai_clifford_sync_success(self, mocker, mock_circuit_qasm, mock_backend):
        """
        Successful test AI Clifford synthesis sync tool with mocked backend, QASM quantum circuit and PassManager
        """
        mock_response = {
            "status": "success",
            "optimized_circuit_qasm": "optimized_circuit_qasm",
        }
        mocker_run_sync = mocker.patch(
            "qiskit_ibm_transpiler_mcp_server.sync._run_async",
            return_value=mock_response,
        )
        result = ai_clifford_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "success"
        assert result["optimized_circuit_qasm"] == "optimized_circuit_qasm"
        mocker_run_sync.assert_called_once()

    @pytest.mark.parametrize(
        "get_backend_fixture, load_qasm_fixture, pass_manager_fixture, dumps_fixture, ai_clifford_synthesis_fixture, expected_message",
        [
            (
                "mock_get_backend_service_failure",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_clifford_synthesis_success",
                "get_backend failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_failure",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_clifford_synthesis_success",
                "Error in loading QuantumCircuit from QASM3.0",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_failure",
                "mock_dumps_qasm_success",
                "mock_ai_clifford_synthesis_success",
                "PassManager run failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_failure",
                "mock_ai_clifford_synthesis_success",
                "QASM dumps failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_clifford_synthesis_failure",
                "AI Clifford synthesis failed",
            ),
        ],
        indirect=[
            "get_backend_fixture",
            "load_qasm_fixture",
            "pass_manager_fixture",
            "dumps_fixture",
            "ai_clifford_synthesis_fixture",
        ],
    )
    def test_ai_clifford_synthesis_sync_failures_parametrized(
        self,
        get_backend_fixture,
        load_qasm_fixture,
        pass_manager_fixture,
        dumps_fixture,
        ai_clifford_synthesis_fixture,
        expected_message,
        mock_circuit_qasm,
        mock_backend,
    ):
        """
        Failed test AI Clifford synthesis sync tool with existing backend, quantum circuit and PassManager.
        """
        result = ai_clifford_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "error"
        assert expected_message in result["message"]


class TestAILinearFunctionSync:
    """Test AI Linear Function synthesis sync tool."""

    def test_ai_linear_function_sync_success(
        self, mocker, mock_circuit_qasm, mock_backend
    ):
        """
        Successful test AI Linear Function synthesis sync tool with mocked backend, QASM quantum circuit and PassManager
        """
        mock_response = {
            "status": "success",
            "optimized_circuit_qasm": "optimized_circuit_qasm",
        }
        mocker_run_sync = mocker.patch(
            "qiskit_ibm_transpiler_mcp_server.sync._run_async",
            return_value=mock_response,
        )
        result = ai_linear_function_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "success"
        assert result["optimized_circuit_qasm"] == "optimized_circuit_qasm"
        mocker_run_sync.assert_called_once()

    @pytest.mark.parametrize(
        "get_backend_fixture, load_qasm_fixture, pass_manager_fixture, dumps_fixture, ai_linear_function_synthesis_fixture, expected_message",
        [
            (
                "mock_get_backend_service_failure",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_linear_function_synthesis_success",
                "get_backend failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_failure",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_linear_function_synthesis_success",
                "Error in loading QuantumCircuit from QASM3.0",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_failure",
                "mock_dumps_qasm_success",
                "mock_ai_linear_function_synthesis_success",
                "PassManager run failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_failure",
                "mock_ai_linear_function_synthesis_success",
                "QASM dumps failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_linear_function_synthesis_failure",
                "AI Linear Function synthesis failed",
            ),
        ],
        indirect=[
            "get_backend_fixture",
            "load_qasm_fixture",
            "pass_manager_fixture",
            "dumps_fixture",
            "ai_linear_function_synthesis_fixture",
        ],
    )
    def test_ai_linear_function_synthesis_sync_failures_parametrized(
        self,
        get_backend_fixture,
        load_qasm_fixture,
        pass_manager_fixture,
        dumps_fixture,
        ai_linear_function_synthesis_fixture,
        expected_message,
        mock_circuit_qasm,
        mock_backend,
    ):
        """
        Failed test AI Linear Function synthesis sync tool with existing backend, quantum circuit and PassManager
        """
        result = ai_linear_function_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "error"
        assert expected_message in result["message"]


class TestAIPermutationSync:
    """Test AI Permutation synthesis sync tool."""

    def test_ai_permutation_sync_success(self, mocker, mock_circuit_qasm, mock_backend):
        """
        Successful test AI Permutation synthesis sync tool with mocked backend, QASM quantum circuit and PassManager
        """
        mock_response = {
            "status": "success",
            "optimized_circuit_qasm": "optimized_circuit_qasm",
        }
        mocker_run_sync = mocker.patch(
            "qiskit_ibm_transpiler_mcp_server.sync._run_async",
            return_value=mock_response,
        )
        result = ai_permutation_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "success"
        assert result["optimized_circuit_qasm"] == "optimized_circuit_qasm"
        mocker_run_sync.assert_called_once()

    @pytest.mark.parametrize(
        "get_backend_fixture, load_qasm_fixture, pass_manager_fixture, dumps_fixture, ai_permutation_synthesis_fixture, expected_message",
        [
            (
                "mock_get_backend_service_failure",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_permutation_synthesis_success",
                "get_backend failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_failure",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_permutation_synthesis_success",
                "Error in loading QuantumCircuit from QASM3.0",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_failure",
                "mock_dumps_qasm_success",
                "mock_ai_permutation_synthesis_success",
                "PassManager run failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_failure",
                "mock_ai_permutation_synthesis_success",
                "QASM dumps failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_permutation_synthesis_failure",
                "Permutation synthesis failed",
            ),
        ],
        indirect=[
            "get_backend_fixture",
            "load_qasm_fixture",
            "pass_manager_fixture",
            "dumps_fixture",
            "ai_permutation_synthesis_fixture",
        ],
    )
    def test_ai_permutation_synthesis_sync_failures_parametrized(
        self,
        get_backend_fixture,
        load_qasm_fixture,
        pass_manager_fixture,
        dumps_fixture,
        ai_permutation_synthesis_fixture,
        expected_message,
        mock_circuit_qasm,
        mock_backend,
    ):
        """
        Failed test AI Permutation synthesis sync tool with existing backend, quantum circuit and PassManager
        """
        result = ai_permutation_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "error"
        assert expected_message in result["message"]


class TestAIPauliNetworkSync:
    """Test AI Pauli Network synthesis sync tool."""

    def test_ai_pauli_network_sync_success(
        self, mocker, mock_circuit_qasm, mock_backend
    ):
        """
        Successful test AI Pauli Network synthesis sync tool with mocked backend, QASM quantum circuit and PassManager
        """
        mock_response = {
            "status": "success",
            "optimized_circuit_qasm": "optimized_circuit_qasm",
        }
        mocker_run_sync = mocker.patch(
            "qiskit_ibm_transpiler_mcp_server.sync._run_async",
            return_value=mock_response,
        )
        result = ai_pauli_network_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "success"
        assert result["optimized_circuit_qasm"] == "optimized_circuit_qasm"
        mocker_run_sync.assert_called_once()

    @pytest.mark.parametrize(
        "get_backend_fixture, load_qasm_fixture, pass_manager_fixture, dumps_fixture, ai_pauli_networks_synthesis_fixture, expected_message",
        [
            (
                "mock_get_backend_service_failure",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_pauli_network_synthesis_success",
                "get_backend failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_failure",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_pauli_network_synthesis_success",
                "Error in loading QuantumCircuit from QASM3.0",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_failure",
                "mock_dumps_qasm_success",
                "mock_ai_pauli_network_synthesis_success",
                "PassManager run failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_failure",
                "mock_ai_pauli_network_synthesis_success",
                "QASM dumps failed",
            ),
            (
                "mock_get_backend_service_success",
                "mock_load_qasm_circuit_success",
                "mock_pass_manager_success",
                "mock_dumps_qasm_success",
                "mock_ai_pauli_network_synthesis_failure",
                "Pauli Networks synthesis failed",
            ),
        ],
        indirect=[
            "get_backend_fixture",
            "load_qasm_fixture",
            "pass_manager_fixture",
            "dumps_fixture",
            "ai_pauli_networks_synthesis_fixture",
        ],
    )
    def test_ai_pauli_networks_synthesis_sync_failures_parametrized(
        self,
        get_backend_fixture,
        load_qasm_fixture,
        pass_manager_fixture,
        dumps_fixture,
        ai_pauli_networks_synthesis_fixture,
        expected_message,
        mock_circuit_qasm,
        mock_backend,
    ):
        """
        Failed test AI Pauli Network synthesis sync tool with existing backend, quantum circuit and PassManager
        """
        result = ai_pauli_network_synthesis_sync(
            circuit_qasm=mock_circuit_qasm,
            backend_name=mock_backend,
        )
        assert result["status"] == "error"
        assert expected_message in result["message"]


class TestSetupIBMQuantumAccountSync:
    """Test setup_ibm_quantum_account_sync function."""

    def test_setup_account_sync_success(self, mocker):
        """Test successful account setup with sync wrapper."""
        mock_response = {
            "status": "success",
            "message": "IBM Quantum account set up successfully",
            "channel": "ibm_quantum_platform",
            "available_backends": 10,
        }
        run_async_mock = mocker.patch(
            "qiskit_ibm_transpiler_mcp_server.sync._run_async"
        )
        run_async_mock.return_value = mock_response
        result = setup_ibm_quantum_account_sync("test_token")
        assert result["status"] == "success"
        assert result["available_backends"] == 10

    def test_setup_account_sync_empty_token_uses_saved_credentials(self, mocker):
        """Test that empty token falls back to saved credentials."""
        mock_response = {
            "status": "success",
            "message": "IBM Quantum account set up successfully",
            "channel": "ibm_quantum_platform",
            "available_backends": 5,
        }

        run_async_mock = mocker.patch(
            "qiskit_ibm_transpiler_mcp_server.sync._run_async"
        )
        run_async_mock.return_value = mock_response
        result = setup_ibm_quantum_account_sync("")

        assert result["status"] == "success"
        assert result["available_backends"] == 5
