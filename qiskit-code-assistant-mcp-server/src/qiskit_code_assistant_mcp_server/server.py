# This code is part of Qiskit.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""
Qiskit Code Assistant MCP Server

A Model Context Protocol server that provides access to IBM Qiskit Code Assistant
for intelligent quantum code completion and assistance.

Dependencies:
- fastmcp
- httpx
- python-dotenv
"""

import logging
from typing import Any

from fastmcp import FastMCP

from qiskit_code_assistant_mcp_server.constants import (
    QCA_MCP_DEBUG_LEVEL,
    validate_configuration,
)
from qiskit_code_assistant_mcp_server.qca import (
    accept_completion,
    accept_model_disclaimer,
    get_completion,
    get_model,
    get_model_disclaimer,
    get_rag_completion,
    get_service_status,
    list_models,
)
from qiskit_code_assistant_mcp_server.utils import close_http_client


# Configure logging
logging.basicConfig(level=getattr(logging, QCA_MCP_DEBUG_LEVEL, logging.INFO))
logger = logging.getLogger(__name__)

# Initialize FastMCP server
mcp = FastMCP("Qiskit Code Assistant")

logger.info("Qiskit Code Assistant MCP Server initialized")

# Validate configuration on startup
if not validate_configuration():
    logger.error("Configuration validation failed - server may not work correctly")
else:
    logger.info("Configuration validation passed")


##################################################
## MCP Resources
## - https://modelcontextprotocol.io/docs/concepts/resources
##################################################


@mcp.resource("qca://models", mime_type="application/json")
async def list_models_resource() -> dict[str, Any]:
    """List the available models from the Qiskit Code Assistant.

    Returns:
        Dictionary with available models
    """
    return await list_models()


@mcp.resource("qca://model/{model_id}", mime_type="application/json")
async def get_model_resource(model_id: str) -> dict[str, Any]:
    """Get details for the given model.

    Returns:
        Dictionary with info about the given model
    """
    return await get_model(model_id)


@mcp.resource("qca://disclaimer/{model_id}", mime_type="application/json")
async def get_model_disclaimer_resource(model_id: str) -> dict[str, Any]:
    """Get the disclaimer for the given model.

    Returns:
        Dictionary with the given model's diclaimer information
    """
    return await get_model_disclaimer(model_id)


@mcp.resource("qca://status", mime_type="text/plain")
async def get_service_status_resource() -> str:
    """Get current status of the Qiskit Code Assistant service.

    Returns:
        String describing the server's current status
    """
    return await get_service_status()


##################################################
## MCP Tools
## - https://modelcontextprotocol.io/docs/concepts/tools
##################################################


@mcp.tool()
async def accept_model_disclaimer_tool(model_id: str, disclaimer_id: str) -> dict[str, Any]:
    """
    Accept the disclaimer for an available model from the Qiskit Code Assistant.

    Args:
        model_id: The ID of the model for which we want to accept the disclaimer
        disclaimer_id: The ID of the disclaimer we want to accept

    Returns:
        Dictionay containing disclaimer acceptance status
    """
    return await accept_model_disclaimer(model_id, disclaimer_id)


@mcp.tool()
async def get_completion_tool(prompt: str) -> dict[str, Any]:
    """
    Get completion for writing, completing, and optimizing quantum code using Qiskit.

    Args:
        prompt: The prompt for code completion

    Returns:
        Dictionary containing code completion choices and metadata
    """
    return await get_completion(prompt)


@mcp.tool()
async def get_rag_completion_tool(prompt: str) -> dict[str, Any]:
    """
    Get RAG completion for answering conceptual or descriptive questions about Qiskit or Quantum.

    Args:
        prompt: The prompt for RAG-based completion

    Returns:
        Dictionary containing RAG completion choices and metadata
    """
    return await get_rag_completion(prompt)


@mcp.tool
async def accept_completion_tool(completion_id: str) -> dict[str, Any]:
    """
    Accept a suggestion generated by the Qiskit Code Assistant.

    Args:
        completion_id: The ID of the completion to accept

    Returns:
        Dictionary containing completion acceptance status
    """
    return await accept_completion(completion_id)


if __name__ == "__main__":
    import atexit

    logger.info("Starting Qiskit Code Assistant MCP Server")

    # Register cleanup function
    def cleanup() -> None:
        import asyncio

        try:
            asyncio.run(close_http_client())
            logger.info("HTTP client closed successfully")
        except Exception as e:
            logger.error(f"Error closing HTTP client: {e}")

    atexit.register(cleanup)

    try:
        mcp.run(transport="stdio")
    except KeyboardInterrupt:
        logger.info("Server interrupted, shutting down...")
    finally:
        cleanup()


# Assisted by watsonx Code Assistant
